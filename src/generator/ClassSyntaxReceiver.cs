using System.CodeDom.Compiler;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace InfiniteEnumFlags.Generator;

/// <summary>
/// Created on demand before each generation pass
/// </summary>
internal class ClassSyntaxReceiver : ISyntaxReceiver
{
    internal List<Source> Sources { get; } = new();

    public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
    {
        if (syntaxNode is not ClassDeclarationSyntax { BaseList.Types.Count: > 0 } classDeclarationSyntax ||
            !classDeclarationSyntax.BaseList.Types.Any(q =>
            {
                var lst = new List<string>()
                {
                    "IArrayFlags",
                    "IIndexDictionaryFlags"
                };
                return lst.Contains(q.ToString());
            })) return;

        var code = GenerateSource(classDeclarationSyntax);
        var fileName = classDeclarationSyntax.Identifier.ToString();
        Sources.Add(new Source(fileName, code));
    }

    private string GenerateSource(ClassDeclarationSyntax target)
    {
        var source = new StringBuilder();
        source.AppendLine("// <auto-generated/>");
        source.AppendLine($"using InfiniteEnumFlags;");
        var @namespace = target.GetNamespace();
        if (@namespace is not null)
            source.AppendLine($"namespace {@namespace};");
        var body = GenerateClass(target);
        source.AppendLine(body);
        return source.ToString();
    }

    private string GenerateClass(ClassDeclarationSyntax target)
    {
        var itemsMethod = target.Members.OfType<MethodDeclarationSyntax>()
            .Single(q => q.Identifier.Text == "Items");
        var items = ParseEnumItems(itemsMethod) ?? new List<string>();

        using var output = new StringWriter();
        using var writer = new IndentedTextWriter(output);
        writer.WriteLine($"public partial class {target.Identifier}");
        writer.WriteLine("{");
        writer.Indent++;
        writer.WriteLine($"public static readonly Flag None = new(-1);");
        for (var i = 0; i < items.Count; i++)
        {
            writer.WriteLine($"public static readonly Flag {items[i]} = new({i});");
        }
        writer.Indent--;
        writer.WriteLine("}");

        return output.ToString();
    }

    public List<string> ParseEnumItems(MethodDeclarationSyntax method)
    {
        return method.ReturnType.ToString() switch
        {
            "string[]" => ParseArrayItems(method),
            "Dictionary<string, int>" => ParseIndexDictionaryItems(method),
            _ => null
        };
    }

    private List<string> ParseIndexDictionaryItems(MethodDeclarationSyntax method)
    {
        var items = method
            .DescendantNodes().OfType<InitializerExpressionSyntax>()
            .SingleOrDefault(q => q.IsKind(SyntaxKind.CollectionInitializerExpression))?
            .DescendantNodes().Where(q => q.IsKind(SyntaxKind.ComplexElementInitializerExpression));

        if (items is null) return new List<string>();

        var lst = items.Select(item => item.DescendantNodes().OfType<LiteralExpressionSyntax>().ToArray())
            .Select(x => new
            {
                Name = x.Single(q => q.IsKind(SyntaxKind.StringLiteralExpression)).Token.Value!.ToString(),
                Index = int.Parse(x.Single(q => q.IsKind(SyntaxKind.NumericLiteralExpression)).ToString())
            }).ToList();
        return lst.OrderBy(q => q.Index).Select(q => q.Name).ToList();
    }

    public List<string> ParseArrayItems(MethodDeclarationSyntax method)
    {
        var items = method
            .DescendantNodes().OfType<InitializerExpressionSyntax>().SingleOrDefault()?
            .DescendantTokens().Where(q => q.IsKind(SyntaxKind.StringLiteralToken));

        return items is null ? new List<string>() : items.Select(q => q.Value?.ToString()).ToList();
    }


}